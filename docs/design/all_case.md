 
### Case 1: 对于过去偏移的依赖的任务触发    a1  a2  a3  a4  a5b2  b3  b4如果a1失败了，重跑a1的时候应该触发b2,b3,b4重跑。  如果不用TaskGraph如何做？  1)	根据a1的调度时间，和B->A的依赖表达式d(-3,0)算出反向表达式d(0,3)，然后算出a1应该被哪一个range的b依赖。  2)	通过range和b的cron表达式，算出这个range内b的所有执行计划  3)	通过执行计划去数据库里搜索，如果没有找到相应的task，则进行依赖检查  4)	如果通过依赖检查，新建task。  但是这种方案也有几个问题：  1)	首先DAGScheduler依赖检查变得复杂了，本来每次做依赖检查的时候，对于一个job来说，只会新起一个task，但是对于offset依赖任务，可能会新起好几个  2)	如果调度时间改变过，可能会有问题。比如a1当天跑成功了，b2第二天也跑成功了，时间为1:00。然后把B时间从1:00改为2:00。之后重跑a1失败了。之后几天b3,b4因为a1失败也没有跑。然后重跑a1，根据上面的做法算出b2~b4，并且调度时间为2:00，但是对于b2来说，当天已经有一个1:00跑成功了，不需要再触发跑了。  3)	a1重跑的时候如何确定当天b的调度时间已经到了呢，比如a1是10.10号的任务，当天10.12号，当天把a1重跑，会触发10.11~10.13的b跑，可是今天才10.12号呢，不能把10.13的b跑起来。  ### Case 2: 时间+依赖任务触发  当前做法，对于每一个DAGJob，时间到的时候打一个flag，如果通过依赖检查再复位。这种做法有一个bug  A    B  \  /   C  	如果a1失败了, b1成功了，之后C时间到了，time flag=true，没有通过依赖检查，time flag还是true; 第二天a2成功了，b2也成功了，看到C的time flag=true，就会通过依赖检查，然后复位为false，这个时候重跑a1，发现时间没有满足，所以也不会通过依赖检查。  还有一种情况，第一天同上，第二天C时间到了，time flag=true, a2和b2通过依赖检查，之后time flag=false。之后再重跑a1，也无法再触发c1了。### Case 3: 系统中断一段时间重启后能恢复所有任务  对于时间任务来说，由TimeScheduler进行调度，对于一个job来说，每次算出下一次调度时间，加入TimeScheduler中。当时间到的时候，拿走，算出下一次时间放进去。  举例：比如a1一点开始跑，计算出下一次2:00加入TimeScheduler中。在1:30的时候系统中断，6:00才恢复。TimeScheduler扫描到2:00小于当前时间，拿走，并计算出下一次3:00加进来。3:00也小于当前时间，拿走，再把4:00加进来…然后依赖任务也会自动触发。整个调度过程由调度器自动完成，不需要人工参与。### Case 4: 异常重启流程  当前server重启可以做到恢复大部分任务和状态，但是有一种情况可能会丢失状态，即DAGDependChecker中对runtime task的依赖，是没有持久化的。  这部分我是想反正是runtime的，上次调度依赖丢了，还会有下次触发他，他也没强制要求必须依赖于上一次，所以就没有持久化。这部分需要根据业务场景再考虑下，如果要持久化，也是可以做的。### Case 5: 纯时间任务如何实现？  ### Case 6: 纯依赖任务如何实现？### Case 6.1: 依赖单个任务？### Case 6.2: 依赖多个任务，且都是runtime的依赖### Case 6.3: 依赖多个任务，且都是past offset依赖### Case 6.4: 依赖多个任务，且都是current offset依赖### Case 6.5 依赖多个任务，且都是future offset依赖 （暂不支持）### Case 6.6 依赖多个任务，有runtime和past offset依赖### Case 6.7 依赖多个任务，有runtime和current offset依赖### Case 7: 时间+依赖任务如何实现？### Case 8: 不同周期的依赖  比如C依赖于A和B， A 1小时跑一次，B 3小时跑一次。对于不同周期的依赖如何处理，当前做法是子任务配置调度时间### Case 9: 串行任务如何支持？  即一个任务执行还要依赖于自己上一次成功。### Case 10: 当前业务大部分业务是依赖于当天，如果正确选择要依赖于哪几个task?  比如D依赖于A,B,C  

| 时间    | A   |  B  | C   | 
| ------ | ---- | ----| ---- | 
| 10.10  | a1   |     | c1   |  
| 10.11  | a2   |  b2 | c2   |
| 10.12  | a3   |  c2 | c3   |
如果收到上面这堆task，如何正确通过依赖检查？### Case 11: 原地重跑task### Case 12: 手动重跑job### Case 13: 强制执行task### Case 14: 跑一次性任务### Case 15: 强制修改task状态(如果改成成功，应该要自动触发后续任务执行)### Case 16: kill task### Case 17: 查询job依赖图### Case 18: 查询Task执行情况，即task依赖关系### Case 19: 新增job### Case 20: 修改job flag修改为disable，JobGraph还是维护该job依赖关系，只是不会进行依赖检查和后续触发。前端查询job依赖关系，还是能查看到disable的job，只是显示颜色不一样。修改为deleted，则从JobGraph中删除。### Case 21：修改job### Case 21.1: 修改调度时间需要更新TimeScheduler中该job下一次调度时间### Case 21.2 增加调度时间注意任务的依赖关系可能从纯依赖变成时间+依赖，依赖检查的条件不一样了### Case 21.3 移除调度时间注意任务的依赖关系可能从时间+依赖变成了纯依赖，依赖检查条件不一样了### Case 21.4 增加job依赖关系，父任务已跑完### Case 21.5 增加job依赖关系，父任务尚未开始跑### Case 21.6 移除job依赖关系，父任务已跑完### Case 21.7 移除job依赖关系，父任务尚未开始跑### Case 21.8 修改依赖关系，比如移除一个依赖关系，增加另一个依赖关系### Case 22:  B依赖于A过去3天，正常逻辑？### Case 23:  B依赖于A过去3天，且都成功了，这时候成功A过去某一天的数据，应该不需要再重新触发B了### Case 24:  B依赖于A过去3天，某一天失败了，这时候重跑A，应该要触发对应的B### Case 25:  B依赖于A过去3天，某一天失败了，过了好几天重跑，这时候可能要触发好几个B###Case 26:  B依赖于A过去3天，且都成功了，但是中间B修改过调度时间，重跑某一天的a，应该不能触发B调度### Case 27:  B依赖于A过去3天，某一天失败了，但是中间B修改过调度时间  
| 10.10  | 10.11  | 10.12  | 10.13 | 10.14 |
| ------ | ------ | ----   | ----  | ----  |
| a1     | a2     |   a3   |  a4   |  a5  |
|        |  b2    |   b3   |  b4   |     |

如上图，10.10 a1跑成功了，10.11 b2跑成功了，时间为10.11 1:00，这个时候把B时间从1:00->2:00， 当天重跑a1失败了，之后b3,b4不能执行，10.13重跑a1，应该只重跑b3,b4就可以了### Case 28:  固定延迟任务